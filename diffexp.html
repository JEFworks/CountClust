---
layout: default
---

      <h1>
<a id="single-cell-differential-expression-analysis" class="anchor" href="#single-cell-differential-expression-analysis" aria-hidden="true"><span class="octicon octicon-link"></span></a>Single-Cell Differential Expression Analysis</h1>

<p>In this vignette, we show you how perform single cell differential expression analysis using single cell RNA-seq data with the <code>scde</code> package.</p>

<p>The <code>scde</code> package implements routines for fitting individual error models for single-cell RNA-seq measurements. Briefly, the read counts observed for each gene are modeled using a mixture of a negative binomial (NB) distribution (for the amplified/detected transcripts) and low-level Poisson distribution (for the unobserved or background-level signal of genes that failed to amplify or were not detected for other reasons). These models can then be used to identify robustly differentially expressed genes between groups of cells. For more information, please refer to the original manuscript by <a href="http://www.ncbi.nlm.nih.gov/pubmed/24836921"><em>Kharchenko et al.</em></a>.</p>

<h2>
<a id="preparing-data" class="anchor" href="#preparing-data" aria-hidden="true"><span class="octicon octicon-link"></span></a>Preparing data</h2>

<p>The analysis starts with a matrix of read counts. Depending on the protocol, these may be raw numbers of reads mapped to each gene, or count values adjusted for potential biases (sequence dependency, splice variant coverage, etc. - the values must be integers). The <code>scde</code> package includes a subset of the ES/MEF cell dataset published by <a href="http://www.ncbi.nlm.nih.gov/pubmed/24363023"><em>Islam et al.</em></a>. The subset includes first 20 ES and MEF cells. Here we load the cells and define a factor separating ES and MEF cell types:</p>

<div class="highlight highlight-source-r"><pre><span class="pl-c"># load example dataset</span>
data(<span class="pl-smi">es.mef.small</span>)

<span class="pl-c"># factor determining cell types</span>
<span class="pl-smi">sg</span> <span class="pl-k">&lt;-</span> <span class="pl-k">factor</span>(gsub(<span class="pl-s"><span class="pl-pds">"</span>(MEF|ESC).*<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span><span class="pl-cce">\\</span>1<span class="pl-pds">"</span></span>, colnames(<span class="pl-smi">es.mef.small</span>)), <span class="pl-v">levels</span> <span class="pl-k">=</span> c(<span class="pl-s"><span class="pl-pds">"</span>ESC<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>MEF<span class="pl-pds">"</span></span>))
<span class="pl-c"># the group factor should be named accordingly</span>
names(<span class="pl-smi">sg</span>) <span class="pl-k">&lt;-</span> colnames(<span class="pl-smi">es.mef.small</span>)
table(<span class="pl-smi">sg</span>)</pre></div>

<pre><code>## sg
## ESC MEF
##  20  20
</code></pre>

<div class="highlight highlight-source-r"><pre><span class="pl-c"># clean up the dataset</span>
<span class="pl-smi">cd</span> <span class="pl-k">&lt;-</span> clean.counts(<span class="pl-smi">es.mef.small</span>, <span class="pl-v">min.lib.size</span><span class="pl-k">=</span><span class="pl-c1">1000</span>, <span class="pl-v">min.reads</span> <span class="pl-k">=</span> <span class="pl-c1">1</span>, <span class="pl-v">min.detected</span> <span class="pl-k">=</span> <span class="pl-c1">1</span>)</pre></div>

<h2>
<a id="fitting-error-models" class="anchor" href="#fitting-error-models" aria-hidden="true"><span class="octicon octicon-link"></span></a>Fitting error models</h2>

<p>As a next step we fit the error models on which all subsequent calculations will rely. The fitting process relies on a subset of robust genes that are detected in multiple cross-cell comparisons. Here we supply the <code>groups = sg</code> argument, so that the error models for the two cell types are fit independently (using two different sets of "robust" genes). If the <code>groups</code> argument is omitted, the models will be fit using a common set.</p>

<p>Note this step takes a considerable amount of time unless multiple cores are used.</p>

<div class="highlight highlight-source-r"><pre><span class="pl-c"># EVALUATION NOT NEEDED</span>
<span class="pl-c"># calculate models</span>
<span class="pl-smi">o.ifm</span> <span class="pl-k">&lt;-</span> scde.error.models(<span class="pl-v">counts</span> <span class="pl-k">=</span> <span class="pl-smi">cd</span>, <span class="pl-v">groups</span> <span class="pl-k">=</span> <span class="pl-smi">sg</span>, <span class="pl-v">n.cores</span> <span class="pl-k">=</span> <span class="pl-c1">1</span>, <span class="pl-v">threshold.segmentation</span> <span class="pl-k">=</span> <span class="pl-c1">TRUE</span>, <span class="pl-v">save.crossfit.plots</span> <span class="pl-k">=</span> <span class="pl-c1">FALSE</span>, <span class="pl-v">save.model.plots</span> <span class="pl-k">=</span> <span class="pl-c1">FALSE</span>, <span class="pl-v">verbose</span> <span class="pl-k">=</span> <span class="pl-c1">1</span>)</pre></div>

<p>For the purposes of this vignette, the model has been precomputed and can simply be loaded.</p>

<div class="highlight highlight-source-r"><pre>data(<span class="pl-smi">o.ifm</span>)</pre></div>

<p>The <code>o.ifm</code> is a dataframe with error model coefficients for each cell (rows).</p>

<div class="highlight highlight-source-r"><pre>head(<span class="pl-smi">o.ifm</span>)</pre></div>

<p>Here, <code>corr.a</code> and <code>corr.b</code> are slope and intercept of the correlated component fit, <code>conc.*</code> refer to the concomitant fit, <code>corr.theta</code> is the NB over-dispersion, and <code>fail.r</code> is the background Poisson rate (fixed).</p>

<p>Particularly poor cells may result in abnormal fits, most commonly showing negative <code>corr.a</code>, and should be removed.</p>

<div class="highlight highlight-source-r"><pre><span class="pl-c"># filter out cells that don't show positive correlation with</span>
<span class="pl-c"># the expected expression magnitudes (very poor fits)</span>
<span class="pl-smi">valid.cells</span> <span class="pl-k">&lt;-</span> <span class="pl-smi">o.ifm</span><span class="pl-k">$</span><span class="pl-smi">corr.a</span> <span class="pl-k">&gt;</span> <span class="pl-c1">0</span>
table(<span class="pl-smi">valid.cells</span>)</pre></div>

<pre><code>## valid.cells
## TRUE
##   40
</code></pre>

<div class="highlight highlight-source-r"><pre><span class="pl-smi">o.ifm</span> <span class="pl-k">&lt;-</span> <span class="pl-smi">o.ifm</span>[<span class="pl-smi">valid.cells</span>, ]</pre></div>

<p>Here, all the fits were valid.</p>

<p>Finally, we need to define an expression magnitude prior for the genes. Its main function, however, is to define a grid of expression magnitude values on which the numerical calculations will be carried out.</p>

<div class="highlight highlight-source-r"><pre><span class="pl-c"># estimate gene expression prior</span>
<span class="pl-smi">o.prior</span> <span class="pl-k">&lt;-</span> scde.expression.prior(<span class="pl-v">models</span> <span class="pl-k">=</span> <span class="pl-smi">o.ifm</span>, <span class="pl-v">counts</span> <span class="pl-k">=</span> <span class="pl-smi">cd</span>, <span class="pl-v">length.out</span> <span class="pl-k">=</span> <span class="pl-c1">400</span>, <span class="pl-v">show.plot</span> <span class="pl-k">=</span> <span class="pl-c1">FALSE</span>)</pre></div>

<p>Here we used a grid of 400 points, and let the maximum expression magnitude be determined by the default 0.999 quantile (use <code>max.value</code> parameter to specify the maximum expression magnitude explicitly - on log10 scale).</p>

<h2>
<a id="testing-for-differential-expression" class="anchor" href="#testing-for-differential-expression" aria-hidden="true"><span class="octicon octicon-link"></span></a>Testing for differential expression</h2>

<p>To test for differential expression, we first define a factor that specifies which two groups of cells are to be compared. The factor elements correspond to the rows of the model matrix (<code>o.ifm</code>), and can contain <code>NA</code> values (i.e. cells that won't be included in either group). Here we key off the the ES and MEF names.</p>

<div class="highlight highlight-source-r"><pre><span class="pl-c"># define two groups of cells</span>
<span class="pl-smi">groups</span> <span class="pl-k">&lt;-</span> <span class="pl-k">factor</span>(gsub(<span class="pl-s"><span class="pl-pds">"</span>(MEF|ESC).*<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span><span class="pl-cce">\\</span>1<span class="pl-pds">"</span></span>, rownames(<span class="pl-smi">o.ifm</span>)), <span class="pl-v">levels</span>  <span class="pl-k">=</span>  c(<span class="pl-s"><span class="pl-pds">"</span>ESC<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>MEF<span class="pl-pds">"</span></span>))
names(<span class="pl-smi">groups</span>) <span class="pl-k">&lt;-</span> row.names(<span class="pl-smi">o.ifm</span>)
<span class="pl-c"># run differential expression tests on all genes.</span>
<span class="pl-smi">ediff</span> <span class="pl-k">&lt;-</span> scde.expression.difference(<span class="pl-smi">o.ifm</span>, <span class="pl-smi">cd</span>, <span class="pl-smi">o.prior</span>, <span class="pl-v">groups</span>  <span class="pl-k">=</span>  <span class="pl-smi">groups</span>, <span class="pl-v">n.randomizations</span>  <span class="pl-k">=</span>  <span class="pl-c1">100</span>, <span class="pl-v">n.cores</span>  <span class="pl-k">=</span>  <span class="pl-c1">1</span>, <span class="pl-v">verbose</span>  <span class="pl-k">=</span>  <span class="pl-c1">1</span>)</pre></div>

<pre><code>## comparing groups:
##
## ESC MEF
##  20  20
## calculating difference posterior
## summarizing differences
</code></pre>

<div class="highlight highlight-source-r"><pre><span class="pl-c"># top upregulated genes (tail would show top downregulated ones)</span>
head(<span class="pl-smi">ediff</span>[order(<span class="pl-smi">ediff</span><span class="pl-k">$</span><span class="pl-smi">Z</span>, <span class="pl-v">decreasing</span>  <span class="pl-k">=</span>  <span class="pl-c1">TRUE</span>), ])</pre></div>

<pre><code>##                     lb      mle        ub       ce        Z       cZ
## Dppa5a        8.075220 9.984631 11.575807 8.075220 7.160813 5.989598
## Pou5f1        5.370220 7.200073  9.189043 5.370220 7.160328 5.989598
## Gm13242       5.688455 7.677425  9.785734 5.688455 7.159979 5.989598
## Tdh           5.807793 8.075220 10.302866 5.807793 7.159589 5.989598
## Ift46         5.449779 7.359190  9.228822 5.449779 7.150242 5.989598
## 4930509G22Rik 5.409999 7.478528  9.785734 5.409999 7.115605 5.978296
</code></pre>

<div class="highlight highlight-source-r"><pre><span class="pl-c"># write out a table with all the results, showing most significantly different genes (in both directions) on top</span>
write.table(<span class="pl-smi">ediff</span>[order(abs(<span class="pl-smi">ediff</span><span class="pl-k">$</span><span class="pl-smi">Z</span>), <span class="pl-v">decreasing</span> <span class="pl-k">=</span> <span class="pl-c1">TRUE</span>), ], <span class="pl-v">file</span> <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>results.txt<span class="pl-pds">"</span></span>, <span class="pl-v">row.names</span> <span class="pl-k">=</span> <span class="pl-c1">TRUE</span>, <span class="pl-v">col.names</span> <span class="pl-k">=</span> <span class="pl-c1">TRUE</span>, <span class="pl-v">sep</span> <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span><span class="pl-cce">\t</span><span class="pl-pds">"</span></span>, <span class="pl-v">quote</span> <span class="pl-k">=</span> <span class="pl-c1">FALSE</span>)</pre></div>

<p>Alternatively we can run the differential expression on a single gene, and visualize the results:</p>

<div class="highlight highlight-source-r"><pre>scde.test.gene.expression.difference(<span class="pl-s"><span class="pl-pds">"</span>Tdh<span class="pl-pds">"</span></span>, <span class="pl-v">models</span> <span class="pl-k">=</span> <span class="pl-smi">o.ifm</span>, <span class="pl-v">counts</span> <span class="pl-k">=</span> <span class="pl-smi">cd</span>, <span class="pl-v">prior</span> <span class="pl-k">=</span> <span class="pl-smi">o.prior</span>)</pre></div>

<pre><code>##           lb     mle       ub       ce        Z       cZ
## Tdh 5.728235 8.03544 10.30287 5.728235 7.151425 7.151425
</code></pre>

<p><img src="https://github.com/hms-dbmi/scde/raw/master/vignettes/figures/scde-diffexp3-1.png" alt=""></p>

<p>The top and the bottom plots show expression posteriors derived from individual cells (colored lines) and joint posteriors (black lines). The middle plot shows posterior of the expression fold difference between the two cell groups, highlighting the 95% credible interval by the red shading.</p>

<h2>
<a id="correcting-for-batch-effects" class="anchor" href="#correcting-for-batch-effects" aria-hidden="true"><span class="octicon octicon-link"></span></a>Correcting for batch effects</h2>

<p>When the data combines cells that were measured in different batches, it is sometimes necessary to explicitly account for the expression differences that could be explained by the batch composition of the cell groups being compared. The example below makes up a random batch composition for the ES/MEF cells, and re-test the expression difference.</p>

<div class="highlight highlight-source-r"><pre><span class="pl-smi">batch</span> <span class="pl-k">&lt;-</span> as.factor(ifelse(rbinom(nrow(<span class="pl-smi">o.ifm</span>), <span class="pl-c1">1</span>, <span class="pl-c1">0.5</span>) <span class="pl-k">==</span> <span class="pl-c1">1</span>, <span class="pl-s"><span class="pl-pds">"</span>batch1<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>batch2<span class="pl-pds">"</span></span>))
<span class="pl-c"># check the interaction between batches and cell types (shouldn't be any)</span>
table(<span class="pl-smi">groups</span>, <span class="pl-smi">batch</span>)</pre></div>

<pre><code>##       batch
## groups batch1 batch2
##    ESC     11      9
##    MEF      8     12
</code></pre>

<div class="highlight highlight-source-r"><pre><span class="pl-c"># test the Tdh gene again</span>
scde.test.gene.expression.difference(<span class="pl-s"><span class="pl-pds">"</span>Tdh<span class="pl-pds">"</span></span>, <span class="pl-v">models</span> <span class="pl-k">=</span> <span class="pl-smi">o.ifm</span>, <span class="pl-v">counts</span> <span class="pl-k">=</span> <span class="pl-smi">cd</span>, <span class="pl-v">prior</span> <span class="pl-k">=</span> <span class="pl-smi">o.prior</span>, <span class="pl-v">batch</span> <span class="pl-k">=</span> <span class="pl-smi">batch</span>)</pre></div>

<pre><code>##           lb      mle       ub       ce        Z       cZ
## Tdh 3.659705 7.796764 12.01338 3.659705 3.782082 3.782082
</code></pre>

<p><img src="https://github.com/hms-dbmi/scde/raw/master/vignettes/figures/scde-batch-1.png" alt=""></p>

<p>In the plot above, the grey lines are used to show posterior distributions based on the batch composition alone. The expression magnitude posteriors (top and bottom plots) look very similar, and as a result the log2 expression ratio posterior is close to 0. The thin black line shows log2 expression ratio posterior before correction. The batch correction doesn't shift the location, but increases uncertainty in the ratio estimate (since we're controlling for another factor).</p>

<p>Similarly, batch correction can be performed when calculating expression differences for the entire dataset:</p>

<div class="highlight highlight-source-r"><pre><span class="pl-c"># test for all of the genes</span>
<span class="pl-smi">ediff.batch</span> <span class="pl-k">&lt;-</span> scde.expression.difference(<span class="pl-smi">o.ifm</span>, <span class="pl-smi">cd</span>, <span class="pl-smi">o.prior</span>, <span class="pl-v">groups</span> <span class="pl-k">=</span> <span class="pl-smi">groups</span>, <span class="pl-v">batch</span> <span class="pl-k">=</span> <span class="pl-smi">batch</span>, <span class="pl-v">n.randomizations</span> <span class="pl-k">=</span> <span class="pl-c1">100</span>, <span class="pl-v">n.cores</span> <span class="pl-k">=</span> <span class="pl-c1">1</span>, <span class="pl-k">return</span><span class="pl-v">.posteriors</span> <span class="pl-k">=</span> <span class="pl-c1">TRUE</span>, <span class="pl-v">verbose</span> <span class="pl-k">=</span> <span class="pl-c1">1</span>)</pre></div>

<pre><code>## controlling for batch effects. interaction:
##       batch
## groups batch1 batch2
##    ESC     11      9
##    MEF      8     12
## calculating batch posteriors
## calculating batch differences
## calculating difference posterior
## summarizing differences
## adjusting for batch effects
</code></pre>

<h3>
<a id="more-detailed-functions" class="anchor" href="#more-detailed-functions" aria-hidden="true"><span class="octicon octicon-link"></span></a>More detailed functions</h3>

<p>The <code>scde.expression.difference</code> method can return a more extensive set of results, including joint posteriors and the expression fold difference posteriors for all of the exam ined genes:</p>

<p>The joint posteriors can also be obtained explicitly for a particular set of cells:</p>

<div class="highlight highlight-source-r"><pre><span class="pl-c"># calculate joint posterior for ESCs (set return.individual.posterior.modes=T if you need p.modes)</span>
<span class="pl-smi">jp</span> <span class="pl-k">&lt;-</span> scde.posteriors(<span class="pl-v">models</span> <span class="pl-k">=</span> <span class="pl-smi">o.ifm</span>[grep(<span class="pl-s"><span class="pl-pds">"</span>ESC<span class="pl-pds">"</span></span>,rownames(<span class="pl-smi">o.ifm</span>)), ], <span class="pl-smi">cd</span>, <span class="pl-smi">o.prior</span>, <span class="pl-v">n.cores</span> <span class="pl-k">=</span> <span class="pl-c1">1</span>)</pre></div>

<p>The error models fit the intercept and the slope of the NB "correlated" component, providing more consistent expression magnitude estimates among the cells. These can be obtain ed with a quick helper function:</p>

<div class="highlight highlight-source-r"><pre><span class="pl-c"># get expression magntiude estimates</span>
<span class="pl-smi">o.fpm</span> <span class="pl-k">&lt;-</span> scde.expression.magnitude(<span class="pl-smi">o.ifm</span>, <span class="pl-v">counts</span> <span class="pl-k">=</span> <span class="pl-smi">cd</span>)</pre></div>

<p>Drop-out probabilities (as a function of expression magnitudes) for different cells are useful for assessing the quality of the measurements:</p>

<div class="highlight highlight-source-r"><pre><span class="pl-c"># get failure probabilities on the expresison range</span>
<span class="pl-smi">o.fail.curves</span> <span class="pl-k">&lt;-</span> scde.failure.probability(<span class="pl-smi">o.ifm</span>, <span class="pl-v">magnitudes</span> <span class="pl-k">=</span> log((<span class="pl-c1">10</span><span class="pl-k">^</span><span class="pl-smi">o.prior</span><span class="pl-k">$</span><span class="pl-smi">x</span>)<span class="pl-k">-</span><span class="pl-c1">1</span>))
par(<span class="pl-v">mfrow</span> <span class="pl-k">=</span> c(<span class="pl-c1">1</span>,<span class="pl-c1">1</span>), <span class="pl-v">mar</span> <span class="pl-k">=</span> c(<span class="pl-c1">3.5</span>,<span class="pl-c1">3.5</span>,<span class="pl-c1">0.5</span>,<span class="pl-c1">0.5</span>), <span class="pl-v">mgp</span> <span class="pl-k">=</span> c(<span class="pl-c1">2.0</span>,<span class="pl-c1">0.65</span>,<span class="pl-c1">0</span>), <span class="pl-v">cex</span> <span class="pl-k">=</span> <span class="pl-c1">1</span>)
plot(c(), c(), <span class="pl-v">xlim</span><span class="pl-k">=</span>range(<span class="pl-smi">o.prior</span><span class="pl-k">$</span><span class="pl-smi">x</span>), <span class="pl-v">ylim</span><span class="pl-k">=</span>c(<span class="pl-c1">0</span>,<span class="pl-c1">1</span>), <span class="pl-v">xlab</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>expression magnitude (log10)<span class="pl-pds">"</span></span>, <span class="pl-v">ylab</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>drop-out probability<span class="pl-pds">"</span></span>)
<span class="pl-k">invisible</span>(apply(<span class="pl-smi">o.fail.curves</span>[, grep(<span class="pl-s"><span class="pl-pds">"</span>ES<span class="pl-pds">"</span></span>,colnames(<span class="pl-smi">o.fail.curves</span>))], <span class="pl-c1">2</span>, <span class="pl-k">function</span>(<span class="pl-smi">y</span>) lines(<span class="pl-v">x</span> <span class="pl-k">=</span> <span class="pl-smi">o.prior</span><span class="pl-k">$</span><span class="pl-smi">x</span>, <span class="pl-v">y</span> <span class="pl-k">=</span> <span class="pl-smi">y</span>,<span class="pl-v">col</span> <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>orange<span class="pl-pds">"</span></span>)))
<span class="pl-k">invisible</span>(apply(<span class="pl-smi">o.fail.curves</span>[, grep(<span class="pl-s"><span class="pl-pds">"</span>MEF<span class="pl-pds">"</span></span>, colnames(<span class="pl-smi">o.fail.curves</span>))], <span class="pl-c1">2</span>, <span class="pl-k">function</span>(<span class="pl-smi">y</span>) lines(<span class="pl-v">x</span> <span class="pl-k">=</span> <span class="pl-smi">o.prior</span><span class="pl-k">$</span><span class="pl-smi">x</span>, <span class="pl-v">y</span> <span class="pl-k">=</span> <span class="pl-smi">y</span>, <span class="pl-v">col</span> <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>dodgerblue<span class="pl-pds">"</span></span>)))</pre></div>

<p><img src="https://github.com/hms-dbmi/scde/raw/master/vignettes/figures/scde-detailed4-1.png" alt=""></p>

<p>The drop-out probabilities (at a given expression magnitude, or at an observed count) can be useful in subsequent analysis</p>

<div class="highlight highlight-source-r"><pre><span class="pl-c"># get failure probabilities on the expresison range</span>
<span class="pl-smi">o.fail.curves</span> <span class="pl-k">&lt;-</span> scde.failure.probability(<span class="pl-smi">o.ifm</span>, <span class="pl-v">magnitudes</span> <span class="pl-k">=</span> log((<span class="pl-c1">10</span><span class="pl-k">^</span><span class="pl-smi">o.prior</span><span class="pl-k">$</span><span class="pl-smi">x</span>)<span class="pl-k">-</span><span class="pl-c1">1</span>))
<span class="pl-c"># get self-fail probabilities (at a given observed count)</span>
<span class="pl-smi">p.self.fail</span> <span class="pl-k">&lt;-</span> scde.failure.probability(<span class="pl-v">models</span> <span class="pl-k">=</span> <span class="pl-smi">o.ifm</span>, <span class="pl-v">counts</span> <span class="pl-k">=</span> <span class="pl-smi">cd</span>)</pre></div>

<h2>
<a id="adjusted-distance-meaures" class="anchor" href="#adjusted-distance-meaures" aria-hidden="true"><span class="octicon octicon-link"></span></a>Adjusted distance meaures</h2>

<p>The dependency of drop-out probability on the average expression magntiude captured by the cell-speicifc models can be used to adjust cell-to-cell similarity measures, for insta nce in the context of cell clustering. Several such measures are explored below.</p>

<h3>
<a id="direct-drop-out" class="anchor" href="#direct-drop-out" aria-hidden="true"><span class="octicon octicon-link"></span></a>Direct drop-out</h3>

<p>Direct weighting downweights the contribution of a given gene to the cell-to-cell distance based on the probability that the given measurement is a drop-out event (i.e. belongs to the drop-out component) - the "self-fail" probability shown in the previous section. To estimate the adjusted distance, we will simulate the drop-out events, replacing them with <code>NA</code> values, and calculating correlation using the remaining points:</p>

<div class="highlight highlight-source-r"><pre><span class="pl-smi">p.self.fail</span> <span class="pl-k">&lt;-</span> scde.failure.probability(<span class="pl-v">models</span> <span class="pl-k">=</span> <span class="pl-smi">o.ifm</span>, <span class="pl-v">counts</span> <span class="pl-k">=</span> <span class="pl-smi">cd</span>)
<span class="pl-c"># simulate drop-outs</span>
<span class="pl-c"># note: using 10 sampling rounds for illustration here. ~500 or more should be used.</span>
<span class="pl-smi">n.simulations</span> <span class="pl-k">&lt;-</span> <span class="pl-c1">10</span>; <span class="pl-smi">k</span> <span class="pl-k">&lt;-</span> <span class="pl-c1">0.9</span>;
<span class="pl-smi">cell.names</span> <span class="pl-k">&lt;-</span> colnames(<span class="pl-smi">cd</span>); names(<span class="pl-smi">cell.names</span>) <span class="pl-k">&lt;-</span> <span class="pl-smi">cell.names</span>;
<span class="pl-smi">dl</span> <span class="pl-k">&lt;-</span> mclapply(<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-smi">n.simulations</span>,<span class="pl-k">function</span>(<span class="pl-smi">i</span>) {
  <span class="pl-smi">scd1</span> <span class="pl-k">&lt;-</span> do.call(<span class="pl-smi">cbind</span>,lapply(<span class="pl-smi">cell.names</span>,<span class="pl-k">function</span>(<span class="pl-smi">nam</span>) {
    <span class="pl-smi">x</span> <span class="pl-k">&lt;-</span> <span class="pl-smi">cd</span>[,<span class="pl-smi">nam</span>];
    <span class="pl-c"># replace predicted drop outs with NAs</span>
    <span class="pl-smi">x</span>[<span class="pl-k">!</span>as.logical(rbinom(length(<span class="pl-smi">x</span>),<span class="pl-c1">1</span>,<span class="pl-c1">1</span><span class="pl-k">-</span><span class="pl-smi">p.self.fail</span>[,<span class="pl-smi">nam</span>]<span class="pl-k">*</span><span class="pl-smi">k</span>))] <span class="pl-k">&lt;-</span> <span class="pl-c1">NA</span>;
    <span class="pl-smi">x</span>;
    }))
  rownames(<span class="pl-smi">scd1</span>) <span class="pl-k">&lt;-</span> rownames(<span class="pl-smi">cd</span>);
  <span class="pl-c"># calculate correlation on the complete observation pairs</span>
  cor(log10(<span class="pl-smi">scd1</span><span class="pl-k">+</span><span class="pl-c1">1</span>),<span class="pl-v">use</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>pairwise.complete.obs<span class="pl-pds">"</span></span>);
}, <span class="pl-v">mc.cores</span> <span class="pl-k">=</span> <span class="pl-c1">1</span>)
<span class="pl-c"># calculate average distance across sampling rounds</span>
<span class="pl-smi">direct.dist</span> <span class="pl-k">&lt;-</span> as.dist(<span class="pl-c1">1</span><span class="pl-k">-</span>Reduce(<span class="pl-s"><span class="pl-pds">"</span>+<span class="pl-pds">"</span></span>,<span class="pl-smi">dl</span>)<span class="pl-k">/</span>length(<span class="pl-smi">dl</span>))</pre></div>

<h3>
<a id="reciprocal-weighting" class="anchor" href="#reciprocal-weighting" aria-hidden="true"><span class="octicon octicon-link"></span></a>Reciprocal weighting</h3>

<p>The reciprocal weighting of the Pearson correlation will give increased weight to pairs of observations where a gene expressed (on average) at a level x1 observed in a cell c1 would not be likely to fail in a cell c2, and vice versa:</p>

<div class="highlight highlight-source-r"><pre><span class="pl-c"># load boot package for the weighted correlation implementation</span>
require(<span class="pl-smi">boot</span>)
<span class="pl-smi">k</span> <span class="pl-k">&lt;-</span> <span class="pl-c1">0.95</span>;
<span class="pl-smi">reciprocal.dist</span> <span class="pl-k">&lt;-</span> as.dist(<span class="pl-c1">1</span> <span class="pl-k">-</span> do.call(<span class="pl-smi">rbind</span>, mclapply(<span class="pl-smi">cell.names</span>, <span class="pl-k">function</span>(<span class="pl-smi">nam1</span>) {
  unlist(lapply(<span class="pl-smi">cell.names</span>, <span class="pl-k">function</span>(<span class="pl-smi">nam2</span>) {
    <span class="pl-c"># reciprocal probabilities</span>
    <span class="pl-smi">f1</span> <span class="pl-k">&lt;-</span> scde.failure.probability(<span class="pl-v">models</span> <span class="pl-k">=</span> <span class="pl-smi">o.ifm</span>[<span class="pl-smi">nam1</span>,,<span class="pl-v">drop</span> <span class="pl-k">=</span> <span class="pl-c1">FALSE</span>], <span class="pl-v">magnitudes</span> <span class="pl-k">=</span> <span class="pl-smi">o.fpm</span>[, <span class="pl-smi">nam2</span>])
    <span class="pl-smi">f2</span> <span class="pl-k">&lt;-</span> scde.failure.probability(<span class="pl-v">models</span> <span class="pl-k">=</span> <span class="pl-smi">o.ifm</span>[<span class="pl-smi">nam2</span>,,<span class="pl-v">drop</span> <span class="pl-k">=</span> <span class="pl-c1">FALSE</span>], <span class="pl-v">magnitudes</span> <span class="pl-k">=</span> <span class="pl-smi">o.fpm</span>[, <span class="pl-smi">nam1</span>])
    <span class="pl-c"># weight factor</span>
    <span class="pl-smi">pnf</span> <span class="pl-k">&lt;-</span> sqrt((<span class="pl-c1">1</span><span class="pl-k">-</span><span class="pl-smi">f1</span>)<span class="pl-k">*</span>(<span class="pl-c1">1</span><span class="pl-k">-</span><span class="pl-smi">f2</span>))<span class="pl-k">*</span><span class="pl-smi">k</span> <span class="pl-k">+</span>(<span class="pl-c1">1</span><span class="pl-k">-</span><span class="pl-smi">k</span>);
    <span class="pl-e">boot</span><span class="pl-k">::</span>corr(log10(cbind(<span class="pl-smi">cd</span>[, <span class="pl-smi">nam1</span>], <span class="pl-smi">cd</span>[, <span class="pl-smi">nam2</span>])<span class="pl-k">+</span><span class="pl-c1">1</span>), <span class="pl-v">w</span> <span class="pl-k">=</span> <span class="pl-smi">pnf</span>)
    }))
},<span class="pl-v">mc.cores</span> <span class="pl-k">=</span> <span class="pl-c1">1</span>)), <span class="pl-v">upper</span> <span class="pl-k">=</span> <span class="pl-c1">FALSE</span>)</pre></div>

<h3>
<a id="mode-relative-weighting" class="anchor" href="#mode-relative-weighting" aria-hidden="true"><span class="octicon octicon-link"></span></a>Mode-relative weighting</h3>

<p>A more reliable reference magnitude against which drop-out likelihood could be assessed would be an estimate of the average expression magnitude, such as joint posterior mode. Below we estimate <code>p.mode.fail</code>, a probability that a drop-out event could be observed at the level of average expression magntiude in a given cell. For each measurement we then reduce it weight if it indeed dropped out in a cell where we expect it to drop-out given its average expression magnitude <code>(p.self.fail*p.mode.fail)</code>. However we do want to give high weight to measurements where the drop-out was not observed, even though it was exected based on the average expression magnitude, so the overall weight expression is <code>(1-p.self.fail*sqrt(p.self.fail*p.mode.fail))</code> (other formulations are clearly possible here).</p>

<div class="highlight highlight-source-r"><pre><span class="pl-c"># reclculate posteriors with the individual posterior modes </span>
<span class="pl-smi">jp</span> <span class="pl-k">&lt;-</span> scde.posteriors(<span class="pl-v">models</span> <span class="pl-k">=</span> <span class="pl-smi">o.ifm</span>, <span class="pl-smi">cd</span>, <span class="pl-smi">o.prior</span>, <span class="pl-k">return</span><span class="pl-v">.individual.posterior.modes</span> <span class="pl-k">=</span> <span class="pl-c1">TRUE</span>, <span class="pl-v">n.cores</span> <span class="pl-k">=</span> <span class="pl-c1">1</span>)
<span class="pl-c"># find joint posterior modes for each gene - a measure of MLE of group-average expression</span>
<span class="pl-smi">jp</span><span class="pl-k">$</span><span class="pl-smi">jp.modes</span> <span class="pl-k">&lt;-</span> log(as.numeric(colnames(<span class="pl-smi">jp</span><span class="pl-k">$</span><span class="pl-smi">jp</span>)))[max.col(<span class="pl-smi">jp</span><span class="pl-k">$</span><span class="pl-smi">jp</span>)]
<span class="pl-smi">p.mode.fail</span> <span class="pl-k">&lt;-</span> scde.failure.probability(<span class="pl-v">models</span> <span class="pl-k">=</span> <span class="pl-smi">o.ifm</span>, <span class="pl-v">magnitudes</span> <span class="pl-k">=</span> <span class="pl-smi">jp</span><span class="pl-k">$</span><span class="pl-smi">jp.modes</span>)
<span class="pl-c"># weight matrix</span>
<span class="pl-smi">matw</span> <span class="pl-k">&lt;-</span> <span class="pl-c1">1</span><span class="pl-k">-</span>sqrt(<span class="pl-smi">p.self.fail</span><span class="pl-k">*</span>sqrt(<span class="pl-smi">p.self.fail</span><span class="pl-k">*</span><span class="pl-smi">p.mode.fail</span>))
<span class="pl-c"># magnitude matrix (using individual posterior modes here)</span>
<span class="pl-smi">mat</span> <span class="pl-k">&lt;-</span> log10(exp(<span class="pl-smi">jp</span><span class="pl-k">$</span><span class="pl-smi">modes</span>)<span class="pl-k">+</span><span class="pl-c1">1</span>);
<span class="pl-c"># weighted distance</span>
<span class="pl-smi">mode.fail.dist</span> <span class="pl-k">&lt;-</span> as.dist(<span class="pl-c1">1</span><span class="pl-k">-</span>do.call(<span class="pl-smi">rbind</span>,mclapply(<span class="pl-smi">cell.names</span>,<span class="pl-k">function</span>(<span class="pl-smi">nam1</span>) {
  unlist(lapply(<span class="pl-smi">cell.names</span>,<span class="pl-k">function</span>(<span class="pl-smi">nam2</span>) {
    corr(cbind(<span class="pl-smi">mat</span>[, <span class="pl-smi">nam1</span>], <span class="pl-smi">mat</span>[, <span class="pl-smi">nam2</span>]), <span class="pl-v">w</span> <span class="pl-k">=</span> sqrt(sqrt(<span class="pl-smi">matw</span>[, <span class="pl-smi">nam1</span>]<span class="pl-k">*</span><span class="pl-smi">matw</span>[, <span class="pl-smi">nam2</span>])))
  }))
}, <span class="pl-v">mc.cores</span> <span class="pl-k">=</span> <span class="pl-c1">1</span>)), <span class="pl-v">upper</span> <span class="pl-k">=</span> <span class="pl-c1">FALSE</span>)</pre></div>
